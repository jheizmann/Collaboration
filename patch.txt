Index: extensions/Collaboration/ArticleComments/ArticleComments.php
===================================================================
--- extensions/Collaboration/ArticleComments/ArticleComments.php	(revision 5598)
+++ extensions/Collaboration/ArticleComments/ArticleComments.php	(working copy)
@@ -2,8 +2,11 @@
 /**
  * ArticleComments.php - A MediaWiki extension for adding comment sections to articles.
  * @author Jim R. Wilson
+ * @author Steren Giannini
+ * @author Benjamin Langguth
  * @version 0.4.3
  * @copyright Copyright (C) 2007 Jim R. Wilson
+ * @copyright Copyright (C) 2008 Steren Giannini
  * @license The MIT License - http://www.opensource.org/licenses/mit-license.php 
  * -----------------------------------------------------------------------
  * Description:
@@ -92,7 +95,10 @@
 function wfArticleCommentsParserHook( $text, $params = array(), &$parser ) {
  
     # Generate a comment form for display
-    $commentForm = wfArticleCommentForm( $parser->mTitle, $params );
+    /*op-patch|BL|2009-10-15|Collaboration|generalImprovements|start*/
+    // Added $parser to function args
+    $commentForm = wfArticleCommentForm( $parser->mTitle, $params, $parser );
+    /*op-patch|BL|2009-10-15|end*/
     
     # Hide content from the Parser using base64 to avoid mangling.
     # Note: Content will be decoded after Tidy has finished its processing of the page.
@@ -105,7 +111,6 @@
  * @param Array $params A hash of parameters containing rendering options.
  */
 function displayArticleCommentForm( $title = null, $params = array() ) {
- 
     global $wgRequest, $wgArticleCommentsNSDisplayList;
     
     # Short circuit for anything other than action=view or action=purge
@@ -116,13 +121,13 @@
     
     # Short-circuit if displayl ist is undefined or null
     if ($wgArticleCommentsNSDisplayList==null) return;
- 
+
     # Use wgTitle if title is not specified
     if ($title==null) {
         global $wgTitle;
         $title = $wgTitle;
     }
- 
+
     # Ensure that the namespace list is an actual list
     $nsList = $wgArticleCommentsNSDisplayList;
     if (!is_array($nsList)) $nsList = array($nsList);
@@ -133,14 +138,17 @@
     }
     
 }
- 
+
 /**
  * Generates and returns an ArticleComment form.
  * @param Title $title The title of the article on which the form will appear.
  * @param Array $params A hash of parameters containing rendering options.
  */
-function wfArticleCommentForm( $title = null, $params = array() ) {
- 
+ /*op-patch|BL|2009-10-15|Collaboration|generalImprovements|start*/
+ // Added $parser to function args
+function wfArticleCommentForm( $title = null, $params = array(), $parser ) {
+ /*op-patch|BL|2009-10-15|end*/
+
     global $wgScript, $wgArticleCommentDefaults, $wgContentLang, $wgContLang;
     $wcl = ($wgContentLang ? $wgContentLang : $wgContLang);
  
@@ -162,9 +170,14 @@
     
     $ac = 'article-comments-';
     $formAction = $wgScript.'?title='.$wcl->getNsText(NS_SPECIAL).':ProcessComment';
- 
+
     # Build out the comment form.
+    /*op-patch|BL|2009-10-15|Collaboration|generalImprovements|start*/
+    // use the functionality of collapsing tables and check existence of array key
     $content = 
+        '<table style="text-align:left" class="wikitable collapsible collapsed">' .
+        '<th>&nbsp;' . wfMsgForContent($ac.'leave-comment-link') . '</th>' .
+        '<tr><td>' .
         '<div id="commentForm">'.
         '<form method="post" action="'.$formAction.'">'.
         '<input type="hidden" id="titleKey" name="titleKey" '.
@@ -173,7 +186,7 @@
         'value="'.$title->getNamespace().'" />'.
         '<p>'.wfMsgForContent($ac.'name-field').'<br />'.
         '<input type="text" id="commenterName" name="commenterName" /></p>'.
-        ($params['showurlfield']=='false' || $params['showurlfield']===false?'':
+        (array_key_exists('showurlfield',$params) && ($params['showurlfield']=='false' || $params['showurlfield']===false)?'':
             '<p>'.wfMsgForContent($ac.'url-field').'<br />'.
             '<input type="text" id="commenterURL" name="commenterURL" value="http://" /></p>'
         ).
@@ -182,7 +195,9 @@
         '</textarea></p>'.
         '<p><input id="submit" type="submit" '.
         'value="'.wfMsgForContent($ac.'submit-button').'" /></p>'.
-        '</form></div>';
+        '</form></div>' .
+        '</td></tr></table>';
+    /*op-patch|BL|2009-10-15|end*/
         
     # Short-circuit if noScript has been set to anything other than false
     if (isset($params['noscript']) && 
@@ -190,10 +205,10 @@
         $params['noscript']) {
         return $content;
     }
- 
+
     # Inline JavaScript to make form behavior more rich (must degrade well in JS-disabled browsers)
     $content .= "<script type='text/javascript'>//<![CDATA[\n(function(){\n";
- 
+
     # Prefill the name field if the user is logged in.
     $content .= 
         'var prefillUserName = function(){'."\n".
@@ -204,7 +219,7 @@
         '("load",prefillUserName,false);'."\n".
         'else if (window.attachEvent) window.attachEvent'.
         '("onload",prefillUserName);'."\n";
- 
+
     # Prefill comment text if it has been specified by a system message
     # Note: This is done dynamically with JavaScript since it would be annoying
     # for JS-disabled browsers to have the prefilled text (since they'd have
@@ -225,7 +240,7 @@
             'else if (comment.attachEvent) comment.attachEvent'.
             '("onfocus",clearCommentOnFirstFocus);'."\n";
     }
- 
+
     # Hides the commentForm until the "Make a comment" link is clicked
     # Note: To disable, set $wgArticleCommentDefaults['hideForm']=false in LocalSettings.php
     if (!isset($params['hideform']) || 
@@ -241,15 +256,56 @@
             '\'>'.wfMsgForContent($ac.'leave-comment-link').'</a>";'."\n".
             'cf.parentNode.insertBefore(p,cf);'."\n";
     }
- 
+
     $content .= "})();\n//]]></script>";
+
+    # Show the comments inside the page, under the "Make a comment" link.
+    # Note: To enable, set $wgArticleCommentDefaults['displaycomments']=true in LocalSettings.php
+    if (isset($params['displaycomments']) && $params['displaycomments']==true) {
+        global $wgTitle;
+            $talkTitle = $wgTitle->getTalkPage();
+            if ($talkTitle->exists()) {
+                $talkPage = new Article($talkTitle);
+                $content .= '<table style="text-align:left" class="wikitable collapsible collapsed">';
+                $content .= '<th>&nbsp;'.wfMsgForContent($ac.'show-comments-link').'</th><tr><td><div id="comments_text">';
+                $talkPage = new Article($talkTitle);
+
+                global $wgUser,$wgParser;
+                $psr = new Parser; $opt = ParserOptions::newFromUser($wgUser) ;
+                $opt->setTemplateCallback(true);
+                $talkpage_html = $psr->parse($talkPage->fetchContent(),$talkTitle,$opt,true,true)->getText();
+                /*op-patch|BL|2009-10-15|Collaboration|generalImprovements|start*/
+                // remove the comments tag
+                $content .= str_replace( '&lt;comments /&gt;', '', $talkpage_html );
+                /*op-patch|BL|2009-10-15|end*/
+                $content .='</div></td></tr></table>';
+            }
+        # Hides the comment text until the "Show comments" link is clicked
+        # Note: To disable, set $wgArticleCommentDefaults['hidecomments']=false in LocalSettings.php
+        if (!isset($params['hidecomments']) || 
+            ($params['hidecomments']!='false' &&
+            !$params['hidecomments']===false)) {
+            $content .= "<script type='text/javascript'>//<![CDATA[\n(function(){\n";
+            $content .= 
+                'var cf=document.getElementById("comments_text");'."\n".
+                'cf.style.display="none";'."\n".
+                'var p=document.createElement("p");'."\n".
+                'p.innerHTML="<a href=\'javascript:void(0)\' onclick=\''.
+                'document.getElementById(\\"comments_text\\").style.display=\\"block\\";'.
+                'this.style.display=\\"none\\";false'.
+                '\'>'.wfMsgForContent($ac.'show-comments-link').'</a>";'."\n".
+                'cf.parentNode.insertBefore(p,cf);'."\n";
+            $content .= "})();\n//]]></script>";
+        }
+    }
+
     return $content;
 }
- 
+
 # Attach Hooks
 $wgHooks['ParserAfterTidy'][] = 'wfProcessEncodedContent';
 $wgHooks['ArticleCommentsSpamCheck'][] = 'defaultArticleCommentSpamCheck';
- 
+
 /**
  * Processes HTML comments with encoded content.
  * Usage: $wgHooks['OutputPageBeforeHTML'][] = 'wfProcessEncodedContent';
@@ -265,14 +321,17 @@
     );
     return true;
 }
- 
+
 # Sets up special page to handle comment submission
 $wgExtensionFunctions[] = 'setupSpecialProcessComment';
 function setupSpecialProcessComment() {
     global $IP, $wgMessageCache;
     require_once($IP.'/includes/SpecialPage.php');
-    SpecialPage::addPage(new SpecialPage('ProcessComment', '', true, 'specialProcessComment', false));
- 
+    /*op-patch|BL|2009-10-15|Collaboration|generalImprovements|start*/
+    // Hide from Special:Specialpages
+    SpecialPage::addPage(new SpecialPage('ProcessComment', '', false, 'specialProcessComment', false));
+    /*op-patch|BL|2009-10-15|end*/
+
     # Messages used in this extension
     $wgMessageCache->addMessage('article-comments-title-field', 'Title');
     $wgMessageCache->addMessage('article-comments-name-string', 'Name');
@@ -282,12 +341,13 @@
     $wgMessageCache->addMessage('article-comments-comment-field', 'Comment: ');
     $wgMessageCache->addMessage('article-comments-submit-button', 'Submit');
     $wgMessageCache->addMessage('article-comments-leave-comment-link', 'Leave a comment ...');
+    $wgMessageCache->addMessage('article-comments-show-comments-link', 'Show comments ...');
     $wgMessageCache->addMessage('article-comments-invalid-field', 'The $1 provided <nowiki>[$2]</nowiki> is invalid.');
     $wgMessageCache->addMessage('article-comments-required-field', '$1 field is required.');
     $wgMessageCache->addMessage('article-comments-submission-failed', 'Comment Submission Failed');
     $wgMessageCache->addMessage('article-comments-failure-reasons', 'Sorry, your comment submission failed for the following reason(s):');
     $wgMessageCache->addMessage('article-comments-no-comments', 'Sorry, the article &quot;[[$1]]&quot; is not accepting comments at this time.');
-    $wgMessageCache->addMessage('article-comments-talk-page-starter', "<noinclude>Comments on [[$1]]\n<comments />\n----- __NOEDITSECTION__</noinclude>\n");
+    $wgMessageCache->addMessage('article-comments-talk-page-starter', "<noinclude>Comments on [[$1]]\n----- __NOEDITSECTION__ __NOTOC__ </noinclude>\n");
     $wgMessageCache->addMessage('article-comments-commenter-said', '$1 said ...');
     $wgMessageCache->addMessage('article-comments-summary', 'Comment provided by $1 - via ArticleComments extension');
     $wgMessageCache->addMessage('article-comments-submission-succeeded', 'Comment submission succeeded');
@@ -299,22 +359,25 @@
     $wgMessageCache->addMessage('article-comments-no-spam', "At least one of the submitted fields was flagged as spam.");
     $wgMessageCache->addMessage('processcomment', 'Process Article Comment');
 }
- 
+
 /**
 * Special page for comment processing.
 */
 function specialProcessComment() {
- 
+
     global $wgOut, $wgParser, $wgUser, $wgContentLang, $wgContLang;
     $wcl = ($wgContentLang ? $wgContentLang : $wgContLang);
- 
+
     # Retrieve submitted values
-    $titleKey = $_POST['titleKey'];
-    $titleNS = intval($_POST['titleNS']);
-    $commenterName = $_POST['commenterName'];
+    /*op-patch|BL|2009-10-15|Collaboration|generalImprovements|start*/
+    // fixed php notices
+    $titleKey = isset($_POST['titleKey']) ? $_POST['titleKey'] : NULL;
+    $titleNS = isset($_POST['titleNS']) ? intval($_POST['titleNS']) : NULL;
+    $commenterName = isset($_POST['commenterName']) ? $_POST['commenterName'] : NULL;
     $commenterURL = isset($_POST['commenterURL']) ? $_POST['commenterURL'] : '';
-    $comment = $_POST['comment'];
- 
+    $comment = isset($_POST['comment']) ? $_POST['comment'] : NULL;
+    /*op-patch|BL|2009-10-15|end*/
+
     # Perform validation checks on supplied fields
     $ac = 'article-comments-';
     $messages = array();
@@ -335,16 +398,16 @@
         $wgOut->addWikiText($wikiText . "</div>");
         return;
     }
- 
+
     # Setup title and talkTitle object
     $title = Title::newFromDBkey($titleKey);
     $title->mNamespace = $titleNS - ($titleNS % 2);
     $article = new Article($title);
- 
+
     $talkTitle = Title::newFromDBkey($titleKey);
     $talkTitle->mNamespace = $titleNS + 1 - ($titleNS % 2);
     $talkArticle = new Article($talkTitle);
- 
+
     # Check whether user is blocked from editing the talk page
     if ($wgUser->isBlockedFrom($talkTitle)) {
         $wgOut->setPageTitle(wfMsgForContent($ac.'submission-failed'));
@@ -354,13 +417,13 @@
         $wgOut->addWikiText($wikiText . "</div>");
         return;
     }
- 
+
     # Retrieve article content
     $articleContent = '';
     if ( $article->exists() ) {
         $articleContent = $article->getContent();
     }
- 
+
     # Retrieve existing talk content
     $talkContent = '';
     if ( $talkTitle->exists() ) {
@@ -376,7 +439,7 @@
         in_array($talkTitle->getNamespace(),$wgArticleCommentsNSDisplayList):
         false
     );
- 
+
     # Check whether the article or its talk page contains a <comments /> flag
     if (!$skipCheck &&
         preg_match('/<comments( +[^>]*)?\\/>/', $articleContent)===0 &&
@@ -390,11 +453,11 @@
         );
         return;
     }
- 
+
     # Run spam checks
     $isspam = false;
 	wfRunHooks( 'ArticleCommentsSpamCheck', array( $comment , $commenterName, $commenterURL, &$isspam ) );
- 
+
     # If it's spam - it's gone!
     if ($isspam) {
         $wgOut->setPageTitle(wfMsgForContent($ac.'submission-failed'));
@@ -447,12 +510,18 @@
         $talkArticle->$method($talkContent, $summary, false, false);
         return;
     }
- 
+
     $wgOut->setPageTitle(wfMsgForContent($ac.'submission-succeeded'));
     $wgOut->addWikiText(wfMsgForContent($ac.'submission-success', $title->getPrefixedText()));
     $wgOut->addWikiText(wfMsgForContent($ac.'submission-view-all', $talkTitle->getPrefixedText()));
+    
+    /*op-patch|BL|2009-10-15|Collaboration|generalImprovements|start*/
+    // make a redirect to same page with action=purge (feels linke ajax now)
+    global $wgServer, $wgScriptPath;
+    $wgOut->redirect($wgServer.$wgScriptPath.'/index.php/'.$title->getPrefixedText()."?action=purge");
+    /*op-patch|BL|2009-10-15|end*/
 }
- 
+
 /**
  * Checks ArticleComment fields for SPAM.
  * Usage: $wgHooks['ArticleCommentsSpamCheck'][] = 'defaultArticleCommentSpamCheck';
@@ -463,7 +532,7 @@
  * @return Boolean Always true to indicate other hooking methods may continue to check for spam.
  */
 function defaultArticleCommentSpamCheck($comment, $commenterName, $commenterURL, $isspam) {
- 
+
     # Short-circuit if spam has already been determined
     if ($isspam) return true;
     $fields = array($comment, $commenterName, $commenterURL);
@@ -475,7 +544,7 @@
             if ( preg_match( $wgSpamRegex, $field ) ) return $isspam = true;
         }
     }
- 
+
     # Rudimentary spam protection
     $spampatterns = array(
         '%\\[url=(https?|ftp)://%smi',
@@ -501,5 +570,5 @@
     # We made it this far, leave $isspam alone and give other implementors a chance.
     return true;
 }
- 
-//
\ No newline at end of file
+
+//</source>
\ No newline at end of file
Index: extensions/Collaboration/CurrentUsers/CurrentUsers.php
===================================================================
--- extensions/Collaboration/CurrentUsers/CurrentUsers.php	(revision 5598)
+++ extensions/Collaboration/CurrentUsers/CurrentUsers.php	(working copy)
@@ -72,7 +72,12 @@
         }
         if ( $guests ) $users .= "{" . "{" . "$egCurrentUsersTemplate|Guests||$guests}" . "}\n";
         if ( $bots )   $users .= "{" . "{" . "$egCurrentUsersTemplate|Robots||$bots}" . "}\n";
-        $users =  $parser->preprocess( $users, $wgTitle, $parser->mOptions );
+        /*op-patch|BL|2009-10-15|Collaboration|generalImprovements|start*/
+        // use a new ParserObject for parsing to prevent "UNIQ" strings!
+        // content was: $users = $parser->preprocess( $users, $wgTitle, $parser->mOptions );
+        $localParser = new Parser();
+        $users = $localParser->preprocess( $users, $wgTitle, $parser->mOptions );
+        /*op-patch|BL|2009-10-15|end*/
         return array(
                 $users,
                 'found'   => true,
